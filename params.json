{"name":"Restful Zend Framework","tagline":"RESTful services with Zend Framework","body":"This extension for Zend Framework, allows to create RESTful Controllers with ease.\r\nplease keep in mind that these instructions are general and you should probably customize the code to fit your needs.\r\n\r\nfor a working example please refer to [github.com/codeinchaos/restful-zend-framework-example](https://github.com/codeinchaos/restful-zend-framework-example)\r\n\r\n## Assumptions\r\n* you are building a mixed application (regular ZF Controllers + RESTful controllers)\r\n* your controllers can be a a mix of regular controllers and RESTful controllers or a hybrid!\r\n\r\nI recommend creating a separate [module](http://framework.zend.com/manual/1.12/en/zend.controller.modular.html) for the RESTful controllers, its less complicated to manage this way, and you don't have to worry about advanced REST routing ...\r\nHowever, you can have pie and eat it too! It's possible to have any single Controller act as both a REST controller and a typical Zend MVC controller (HTML output).\r\n\r\nIn this particular example, I'm using a separate module \"Api\" that is purely used for REST API calls.\r\n\r\n## Steps\r\n1. Copy the **REST** directory into your **library**.\r\n2. modify **application.ini**.\r\n3. modify **application/Bootstrap.php**.\r\n4. modify your RESTful module Bootstrap ex: **application/modules/api/Bootstrap.php**.\r\n5. create Controllers as usual, just make sure they extends **REST_Controller**.\r\n6. check https://github.com/codeinchaos/restful-zend-framework-example for examples.\r\n7. reccomended: use the Api_ErrorController provided in the example above, modify to your needs.\r\n\r\n### application.ini:\r\n\r\nadd the following:\r\n\r\n```ini\r\nautoloaderNamespaces[] = \"REST_\"\r\n\r\nrest.default = \"xml\"\r\nrest.formats[] = \"json\"\r\nrest.formats[] = \"xml\"\r\n```\r\n\r\nthe above achieves a couple of things:\r\n\r\n1. Autoloads the REST library\r\n2. sets the default respond format when all content type negotiation fails (in the above example: `xml`)\r\n3. determines the list of content types you want to support in your API, built in types include: `html`, `xml`, `php`, `json`\r\n\r\n### application/Bootstrap.php\r\n\r\nadd the following:\r\n\r\n```php\r\n<?php\r\npublic function _initREST()\r\n{\r\n    $frontController = Zend_Controller_Front::getInstance();\r\n\r\n    // set custom request object\r\n    $frontController->setRequest(new REST_Request);\r\n    $frontController->setResponse(new REST_Response);\r\n\r\n    // add the REST route for the API module only\r\n    $restRoute = new Zend_Rest_Route($frontController, array(), array('api'));\r\n    $frontController->getRouter()->addRoute('rest', $restRoute);\r\n}\r\n```\r\n\r\nIn the above example, we are only enabling RESTful responses on a particular route, which is the `Api` module, look up the `Zend_Rest_Route` docs for further configuration options.\r\n\r\n### application/modules/api/Bootstrap.php\r\n\r\n**Note:** depending on your setup, you may want to setup some advanced rules to enable the **REST Plugin** and the **Action Helpers** only when needed.\r\nI use a modified Bootstraping method called \"Active Bootstrap\" (google it) to only run the bootstrap **_init** methods per active module, which saves me a lot of headaches.\r\n\r\n```php\r\n<?php\r\npublic function _initREST()\r\n{\r\n    $frontController = Zend_Controller_Front::getInstance();\r\n\r\n    // register the RestHandler plugin\r\n    $frontController->registerPlugin(new REST_Controller_Plugin_RestHandler($frontController));\r\n\r\n    // add REST contextSwitch helper\r\n    $contextSwitch = new REST_Controller_Action_Helper_ContextSwitch();\r\n    Zend_Controller_Action_HelperBroker::addHelper($contextSwitch);\r\n\r\n    // add restContexts helper\r\n    $restContexts = new REST_Controller_Action_Helper_RestContexts();\r\n    Zend_Controller_Action_HelperBroker::addHelper($restContexts);\r\n}\r\n```\r\n\r\n## Module Specific ErrorController issue\r\n\r\nIt seems there is an inherit issue with Zend Framework's modules & calling the  ErroController, basically ZF calls the default module's error controller for all modules.\r\nThis can be a problem of course if one of your modules is an API, you'll end up with HTML in the REST ErrorController output.\r\n\r\nto fix this is beyond the scope of the REST library, so its only included in the README file:\r\n\r\nin your ```application.ini```\r\n\r\n```ini\r\nresources.frontController.plugins.ErrorHandler.class = \"Zend_Controller_Plugin_ErrorHandler\"\r\nresources.frontController.plugins.ErrorHandler.options.module = \"default\"\r\nresources.frontController.plugins.ErrorHandler.options.controller = \"error\"\r\nresources.frontController.plugins.ErrorHandler.options.action = \"error\"\r\n```\r\n\r\nthen create a plugin to change the \"module\" scope, you can name this whatever you want, I went with ```App_Controller_Plugin_Errors```:\r\n\r\n```php\r\n<?php\r\nclass App_Controller_Plugin_Errors extends Zend_Controller_Plugin_Abstract\r\n{\r\n    public function routeShutdown(Zend_Controller_Request_Abstract $request)\r\n    {\r\n        $frontController = Zend_Controller_Front::getInstance();\r\n\r\n        $error = $frontController->getPlugin('Zend_Controller_Plugin_ErrorHandler');\r\n\r\n        $error->setErrorHandlerModule($request->getModuleName());\r\n    }\r\n}\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}